# WebRTC

<p align="center"><img align="center" src="webrtc.png"></p>

[WebRTC](https://webrtc.org/) is a free and open-source project providing web browsers and mobile applications with real-time peer-to-peer communications.

## Index

* [SDP](#sdp)
* [ICE](#ice)
* [Topologies](#topologies)
  * [Mesh](#mesh)
  * [MCU](#mcu)
  * [SFU](#sfu)
* [Simulcast](#simulcast)
* [References](#references)

## SDP

## ICE

[Interactive Connectivity Establishment (ICE)](https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment) is a protocol for [Network Address Translator (NAT)](https://en.wikipedia.org/wiki/Network_address_translation) traversal used in computer networking to find ways for two computers to talk to each other as directly as possible in [peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer) networking.

In a real world scenario, establishing a connection between 2 peers using ICE has the following steps:

**1. Address discovery**

Each peer has a private address behind a NAT, to discover their public addresses each peer uses the [Session Traversal Utilities for NAT (STUN)](https://en.wikipedia.org/wiki/STUN) server.

<p align="center"><img align="center" width="50%" height="50%" src="ice_1_stun.png"></p>

**2. Caller relay allocation**

The caller allocates a session in the [Traversal Using Relays around NAT (TURN)](https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT) server. The TURN server **relays** the data between two peers when a direct connection is not possible.

<p align="center"><img align="center" width="50%" height="50%" src="ice_2_caller_turn.png"></p>

**3. Caller sends offer**

The caller sends a connection **offer** to the callee using a [signaling server](https://en.wikipedia.org/wiki/Signaling_gateway) (both peers are already registered in the signaling server).

<p align="center"><img align="center" width="50%" height="50%" src="ice_3_caller_offer.png"></p>

**4. Callee relay allocation**

The callee receives the **offer** and allocates a session in the TURN server.

<p align="center"><img align="center" width="50%" height="50%" src="ice_4_callee_turn.png"></p>

**5. Callee sends answer**

The callee sends a connection **answer** to the caller using the signaling server.

<p align="center"><img align="center" width="50%" height="50%" src="ice_5_callee_answer.png"></p>

**6. Candidate exchange**

During the offer/answer process, each peer **gathers** candidates to be used for ICE. Each candidate is a potential address/port to receive the data. There are 3 types of candidates:

* **Host**. Generated by the peer by binding to its private IP addresses and ports.
* **Reflex**. Generated by sending STUN messages to a STUN/TURN server. A query message is sent to the STUN server. The query passes through the NAT which creates a binding. The response to the query contains the public IP and port that was generated for the binding.
* **Relay**. Generated in the same way as a reflex candidate. A query message is sent to the TURN server. The query passes through the NAT which creates a NAT binding. The response to the query contains the public IP and port that was generated for the binding.

After each candidate is gathered, the candidate is exchanged with the other peer via the SDP offer/answer or standalone using trickle ICE.

<p align="center"><img align="center" width="50%" height="50%" src="ice_6_candidate_exchange.png"></p>

**7a. Check direct connection**

<p align="center"><img align="center" width="50%" height="50%" src="ice_7a_direct_connection.png"></p>

**7b. Use relay connection**

TURN servers are guaranteed to work, unless NATs where specifically configured to block them, because they are publicly available, however the communication is no longer peer-to-peer

<p align="center"><img align="center" width="50%" height="50%" src="ice_7b_relay_connection.png"></p>

## Topologies

### Mesh

In a mesh topology each peer is directly connected to every other peer. Each peer sends their streams to every single peer and download the streams from every peer.

<p align="center"><img align="center" width="50%" height="50%" src="mesh_topology.png"></p>

For a session with N peers the total number of connections is `O(N²)`.

| Peers                    | N      |
|--------------------------|--------|
| Uplinks                  | N(N-1) |
| Downlinks                | N(N-1) |
| Uplinks<sub>peer</sub>   | N-1    |
| Downlinks<sub>peer</sub> | N-1    |

Pros:
* Low latency.
* Low server loads.
* End-to-end encryption.

Cons:
* Poor scaling.
* High peer loads.
* Connectivity problems with NATs, firewalls, etc.

### MCU

In a Multipoint Conferencing Unit (MCU) topology each peer connects to the MCU server. With a MCU each peer uploads their stream once, the server `decodes` the stream, mixes the streams of all the peers into one and `encodes` the stream to send it back to each peer.

<p align="center"><img align="center" width="50%" height="50%" src="mcu_topology.png"></p>

For a session with N peers the total number of connections is `O(N)`.

| Peers                    | N |
|--------------------------|---|
| Uplinks                  | N |
| Downlinks                | N |
| Uplinks<sub>peer</sub>   | 1 |
| Downlinks<sub>peer</sub> | 1 |

Pros:
* Good scaling.
* Low peer loads.
* No connectivity problems.
* Works well in low bandwidth environments.

Cons:
* High latency.
* High server loads.

### SFU

In a Selective Forwarding Unit (SFU) topology each peer connects to the SFU server. With a SFU each peer uploads their stream once and the server `forwards` the stream to every peer.

<p align="center"><img align="center" width="50%" height="50%" src="sfu_topology.png"></p>

For a session with N peers the total number of connections is `O(N²)`.

| Peers                    | N      |
|--------------------------|--------|
| Uplinks                  | N      |
| Downlinks                | N(N-1) |
| Uplinks<sub>peer</sub>   | 1      |
| Downlinks<sub>peer</sub> | N-1    |

Pros:
* Good scaling.
* Medium peer loads.
* Low server loads.
* No connectivity problems.

Cons:
* No end-to-end encryption (although there are experimental approaches of header only decryption).

## Simulcast

Simulcast allows peers to publish multiple versions of the same stream with different **spatial** or **temporal** encodings, effectively sending more data.

### Spatial

With spatial scalability the lower resolution layers consume less bandwidth than the high resolution ones.

For example:
* High: 1280x720 2.5mbps
* Medium: 640x360 400kbps
* Low: 320x180 125kbps

The peer uses just 17% more bandwidth to publish the three layers.

### Temporal

With temporal scalability it is possible to lower a stream's bitrate by dynamically reducing the stream's frame rate. 

Streams contain mostly **delta** frames which depend on previous **key** frames. If the decoder needs to apply a delta to a key frame that was dropped, it can't render subsequent frames.

When temporal layers are used, frames from the base layer only reference other base layer frames.

<p align="center"><img align="center" width="60%" height="60%" src="temporal_simulcast.png"></p>

For a subscriber with limited bandwidth, it is possible to send only the frames of a specific temporal layer, effectively reducing bandwidth.

## References

* [WebRTC for the Curious](https://webrtcforthecurious.com/)
* [WebRTC Glossary](https://webrtcglossary.com/)
* [WebRTC API MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)
* [Troubleshooter](https://test.webrtc.org/)
* [Samples](https://webrtc.github.io/samples/)
* [Trickle ICE](https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/)
* [An Introduction to WebRTC Simulcast](https://blog.livekit.io/an-introduction-to-webrtc-simulcast-6c5f1f6402eb)
